# hil_tester_cli/pin_emulator.py
import json
import time
from .gpio_controller import GPIOController # Assuming GPIOController is in the same directory

def emulate_hw_pins_from_file(input_json_path: str, gpio_ctrl: GPIOController):
    """
    Parses input JSON and executes hardware pin emulation sequences.
    """
    try:
        with open(input_json_path, 'r') as f:
            input_data = json.load(f)
    except FileNotFoundError:
        print(f"Error: Hardware Input Actions JSON file not found at '{input_json_path}'")
        return None
    except json.JSONDecodeError as e:
        print(f"Error: Could not decode Input JSON file '{input_json_path}': {e}")
        return None

    test_name = input_data.get("test_name", "Unnamed Hardware Test")
    emulation_sequence = input_data.get("emulation_sequence", [])

    # Handle pin_setup if provided (GPIO mode BCM/BOARD)
    # GPIOController already handles this in its __init__ based on argument or default
    pin_setup_config = input_data.get("pin_setup", {})
    # If gpio_ctrl was initialized with a different mode, this won't override it here.
    # Best to pass mode to GPIOController constructor. For now, assume compatible.

    print(f"\nStarting Hardware Pin Emulation for: {test_name}")
    if not emulation_sequence:
        print("Warning: No emulation sequence found in input JSON.")
        return input_data

    for action in emulation_sequence:
        action_id = action.get("action_id", "N/A")
        action_type = action.get("type")
        description = action.get("description", "")
        pin = action.get("pin") # Common for many GPIO actions

        print(f"  Executing Action ID: {action_id} | Type: {action_type} | Pin: {pin or 'N/A'} | Desc: {description}")

        try:
            if action_type == "set_gpio_direction":
                if pin is None or "direction" not in action:
                    print("    Error: 'pin' and 'direction' required. Skipping.")
                    continue
                gpio_ctrl.setup_pin_direction(pin, action["direction"],
                                              action.get("initial_state"),
                                              action.get("pull_up_down"))
            elif action_type == "set_gpio_output":
                if pin is None or "value" not in action:
                    print("    Error: 'pin' and 'value' required. Skipping.")
                    continue
                gpio_ctrl.set_pin_output(pin, action["value"])
            elif action_type == "read_gpio_input":
                if pin is None:
                    print("    Error: 'pin' required. Skipping.")
                    continue
                state = gpio_ctrl.read_pin_input(pin)
                print(f"    Pin {pin} read: {state}")
                # Optionally, compare with action.get("expected_value_for_log") here
            elif action_type == "pulse_gpio_output":
                if pin is None or "duration_ms" not in action:
                    print("    Error: 'pin' and 'duration_ms' required. Skipping.")
                    continue
                gpio_ctrl.pulse_pin_output(pin, action["duration_ms"],
                                           action.get("pulse_state", "high"),
                                           action.get("initial_state"))
            elif action_type == "delay_ms":
                duration = action.get("duration")
                if duration is None:
                    print("    Error: 'duration' missing. Skipping.")
                    continue
                print(f"    Delaying for {duration} ms...")
                time.sleep(int(duration) / 1000.0)
            elif action_type in ["spi_transaction", "i2c_write"]: # Conceptual
                print(f"    Action type '{action_type}' is conceptual and not fully implemented here.")
                # Here you would add calls to an SPIController or I2CController class
            else:
                print(f"    Warning: Unknown action type '{action_type}'. Skipping.")
        except Exception as e:
            print(f"    ERROR during action {action_id}: {e}")
            # Decide if to stop or continue

        time.sleep(0.01) # Small breather

    print("Hardware Pin Emulation Finished.")
    return input_data